#!/bin/sh

# =====================================================

# STATIKFINTECHLLC // MASTER_BOOTSTRAP
# Phase 1: Environment Setup (sh/cyan)
# Phase 2: Credentials & Sync (zsh/red)

# =====================================================

# — PHASE 1 COLORS (Cyan Theme) —
CYAN=’\033[36m’
GREEN=’\033[32m’
RED=’\033[0;31m’
BOLD=’\033[1m’
RESET=’\033[0m’

# — PHASE 1 FUNCTIONS —
print_box() {
echo “${CYAN}┌─────────────────────────────────────────┐${RESET}”
echo “${CYAN}│${BOLD} $1${RESET}${CYAN} │${RESET}”
echo “${CYAN}├─────────────────────────────────────────┤${RESET}”
printf “%s\n” “$2” | while IFS= read -r line; do
printf “${CYAN}│ ${RESET}%-37s${CYAN} │${RESET}\n” “$line”
done
echo “${CYAN}└─────────────────────────────────────────┘${RESET}”
}

progress() {
secs=${1:-1}
echo -ne “   [………………..] (0%)”
sleep 0.2
echo -ne “\r   [#######………….] (35%)”

# Use simple sleep division instead of bc
half=$(awk “BEGIN {printf "%.2f", $secs/2}”)
sleep “$half”
echo -ne “\r   [##############……] (70%)”
sleep “$half”
echo -e “\r   [####################] (100%) ${GREEN}Done${RESET}”
}

# =====================================================

# EXECUTION: PHASE 1 (INSTALLATION)

# =====================================================

clear
print_box “Step 1/3” “Installing System Dependencies…”

# Ensure we have jq, zsh, git, and awk for math
apk update >/dev/null 2>&1 || {
echo “${RED}Error: Failed to update package index${RESET}”
exit 1
}

if ! apk add –no-cache build-base ncurses-dev git zsh jq curl >/dev/null 2>&1; then
echo “${RED}Error: Failed to install dependencies${RESET}”
exit 1
fi
progress 2

print_box “Step 2/3” “Installing Oh-My-Zsh…”
if [ ! -d “$HOME/.oh-my-zsh” ]; then
if ! sh -c “$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)” “” –unattended >/dev/null 2>&1; then
echo “${RED}Error: Failed to install Oh-My-Zsh${RESET}”
exit 1
fi
else
echo “   Oh-My-Zsh already installed.”
fi
progress 1

print_box “Step 3/3” “Setting Zsh as Default…”

# This ensures iSH loads ZSH on next boot
if ! grep -q “exec zsh” ~/.profile 2>/dev/null; then
echo ‘[ -z “$ZSH_VERSION” ] && exec zsh’ >> ~/.profile
fi
progress 0.5

# Verify zsh is installed before handoff
if ! command -v zsh >/dev/null 2>&1; then
echo “${RED}Error: Zsh not found. Cannot proceed.${RESET}”
exit 1
fi

# =====================================================

# EXECUTION: PHASE 2 (HANDOFF TO ZSH)

# =====================================================

cat << ‘EOF’ > /tmp/statik_sync_core.zsh
#!/bin/zsh

# — PHASE 2 COLORS (Red Theme) —
RED=’\033[0;31m’
B_RED=’\033[1;31m’
DARK=’\033[2;31m’
GOLD=’\033[1;33m’
RESET=’\033[0m’

clear

# Digital Rain Header
echo “${DARK}”
cat << “HEADER”

-----

|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|
STATIK_FINTECH // SYSTEM_HANDOFF
|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|*|_|
HEADER
echo “${RESET}”

# — GIT CONFIGURATION UI —
echo “${B_RED}>> INITIALIZING CREDENTIAL PROTOCOL…${RESET}”
echo “”
echo “${DARK}Please enter GitHub Identity for Global Config:${RESET}”

# 1. Username
printf “${B_RED}GitHub Username:${RESET} “
read GH_USER

# Basic validation
if [ -z “$GH_USER” ]; then
echo “${RED}Error: Username cannot be empty${RESET}”
exit 1
fi

# 2. Email (Crucial for commits)
printf “${B_RED}GitHub Email:   ${RESET} “
read GH_EMAIL

if [ -z “$GH_EMAIL” ]; then
echo “${RED}Error: Email cannot be empty${RESET}”
exit 1
fi

# 3. Token
printf “${B_RED}GitHub Token:   ${RESET} “
read -s GH_TOKEN
echo “”
echo “”

if [ -z “$GH_TOKEN” ]; then
echo “${RED}Warning: No token provided. API rate limits will apply.${RESET}”
sleep 2
fi

# — APPLYING GIT CONFIG —
echo “${DARK}>> WRITING CONFIGURATION…${RESET}”

# Set Global Name/Email
git config –global user.name “$GH_USER” || {
echo “${RED}Error: Failed to set git username${RESET}”
exit 1
}

git config –global user.email “$GH_EMAIL” || {
echo “${RED}Error: Failed to set git email${RESET}”
exit 1
}

# Set Credential Helper (Store allows permanent login)
git config –global credential.helper store

# Create credentials file properly with URL encoding
if [ -n “$GH_USER” ] && [ -n “$GH_TOKEN” ]; then
# Proper URL encoding function
urlencode() {
printf ‘%s’ “$1” | od -An -tx1 | tr ’ ’ ‘%’ | tr -d ‘\n’
}

```
# More comprehensive encoding
GH_USER_ENC=$(printf '%s' "$GH_USER" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
GH_TOKEN_ENC=$(printf '%s' "$GH_TOKEN" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')

# Write to ~/.git-credentials with explicit newline
printf "https://%s:%s@github.com\n" "$GH_USER_ENC" "$GH_TOKEN_ENC" > ~/.git-credentials
chmod 600 ~/.git-credentials
printf "${GOLD}[ SUCCESS ] Credentials Encrypted & Stored.${RESET}\n"
```

else
printf “${RED}[ WARNING ] Incomplete credentials. Skipping Auth write.${RESET}\n”
fi
sleep 1

# =====================================================

# EXECUTION: PHASE 3 (REPO SYNC)

# =====================================================

# Spinner Function with better process handling
spinner() {
local pid=$1
local msg=$2
local delay=0.1
local spinstr=‘⣾⣽⣻⢿⡿⣟⣯⣷’
local i=0

```
while kill -0 "$pid" 2>/dev/null; do
    i=$(( (i+1) % 8 ))
    printf "\r${DARK}%-20s${B_RED} [ %s ]${RESET}" "$msg" "${spinstr:$i:1}"
    sleep $delay
done

# Wait for process to fully complete
wait "$pid" 2>/dev/null
return $?
```

}

printf “\n${B_RED}>> ENGAGING REPO SYNC ENGINE…${RESET}\n”

# Create builds directory if it doesn’t exist and enter it
if [ ! -d “builds” ]; then
mkdir -p builds || {
echo “${RED}Error: Cannot create builds directory${RESET}”
exit 1
}
fi

cd builds || {
echo “${RED}Error: Cannot access builds directory${RESET}”
exit 1
}

# Use the token for the API call (Avoids API limits)
if [ -n “$GH_TOKEN” ]; then
AUTH_HEADER=“Authorization: token $GH_TOKEN”
else
AUTH_HEADER=“User-Agent: statik-bot”
fi

JSON_DATA=$(curl -s -H “$AUTH_HEADER” “https://api.github.com/users/$GH_USER/repos?per_page=100”)

# Check if we got valid JSON or an error

IS_VALID=$(echo “$JSON_DATA” | jq -r ‘if type==“array” then “yes” else “no” end’ 2>/dev/null)

if [ “$IS_VALID” != “yes” ]; then
echo “${RED}[ ERROR ] Unable to fetch repos. Check Token or API Status.${RESET}”
ERROR_MSG=$(echo “$JSON_DATA” | jq -r ‘.message // “Unknown error”’ 2>/dev/null)
echo “API Response: $ERROR_MSG”
exit 1
fi

# Get repo list and filter empty lines
REPO_LIST=$(echo “$JSON_DATA” | jq -r ‘.[].clone_url’ | grep -v ‘^$’)
TOTAL_REPOS=$(echo “$REPO_LIST” | wc -l | tr -d ’ ’)

# Handle case of no repos
if [ “$TOTAL_REPOS” -eq 0 ] || [ -z “$REPO_LIST” ]; then
echo “${GOLD}>> NO REPOSITORIES FOUND${RESET}”
exit 0
fi

printf “\r${GOLD}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n”

# FIX: Use process substitution to avoid subshell and maintain COUNT
COUNT=1
while IFS= read -r repo; do
[ -z “$repo” ] && continue

```
dir=$(basename "$repo" .git)
PROGRESS_TAG="[$(printf "%02d" $COUNT)/$TOTAL_REPOS]"

if [ -d "$dir/.git" ]; then
    (cd "$dir" && git pull --ff-only 2>&1 | grep -v "Already up to date" || true) >/dev/null &
    PID=$!
    spinner $PID "$dir"
    EXIT_CODE=$?
    
    if [ $EXIT_CODE -eq 0 ]; then
        printf "\r${DARK}%-20s${RESET} ${GOLD}[ UPDATED ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
    else
        printf "\r${DARK}%-20s${RESET} ${RED}[ FAILED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
    fi
else
    git clone "$repo" "$dir" >/dev/null 2>&1 &
    PID=$!
    spinner $PID "$dir"
    EXIT_CODE=$?
    
    if [ $EXIT_CODE -eq 0 ]; then
        printf "\r${B_RED}%-20s${RESET} ${GOLD}[ CLONED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
    else
        printf "\r${B_RED}%-20s${RESET} ${RED}[ FAILED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
        # Clean up failed clone
        [ -d "$dir" ] && rm -rf "$dir"
    fi
fi
COUNT=$((COUNT + 1))
```

done < <(echo “$REPO_LIST”)

echo “”
echo “${DARK}—————————————–”
echo “${B_RED}  BOOTSTRAP COMPLETE // RESTARTING SHELL”
echo “${DARK}—————————————–${RESET}”
sleep 1
EOF
