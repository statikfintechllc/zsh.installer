#!/bin/sh
# =====================================================
# STATIKFINTECHLLC // MASTER_BOOTSTRAP (UNIVERSAL)
# Compatible: iSH (iOS), WSL (Windows), Linux, macOS
# Smart Detection: Install or Update Mode
# Phase 1: Environment Setup (sh/cyan)
# Phase 2: Credentials & Sync (zsh/red)
# =====================================================

# --- PHASE 1 COLORS (Cyan Theme) ---
ESC=$(printf '\033')
CYAN="${ESC}[36m"
GREEN="${ESC}[32m"
YELLOW="${ESC}[1;33m"
RED="${ESC}[0;31m"
BOLD="${ESC}[1m"
RESET="${ESC}[0m"

# --- DETECT ENVIRONMENT ---
detect_os() {
  uname_s=$(uname -s 2>/dev/null || echo Unknown)
  case "$uname_s" in
    *MINGW*|*MSYS*|*CYGWIN*|*Windows_NT*)
      OS="windows"
      ;;
    Darwin*)
      OS="macos"
      ;;
    *)
      if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
      else
        OS="unknown"
      fi
      ;;
  esac

  # Check if running in WSL
  if [ -f /proc/version ] && grep -qi microsoft /proc/version 2>/dev/null; then
    WSL=true
  else
    WSL=false
  fi
}

# --- CHECK IF ALREADY INSTALLED ---
check_existing_setup() {
  SETUP_EXISTS=false
  SKIP_INSTALL=false

  # Check for .zshrc (indicates Oh-My-Zsh is configured)
  if [ -f "$HOME/.zshrc" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Existing .zshrc detected${RESET}"
  fi

  # Check for Oh-My-Zsh
  if [ -d "$HOME/.oh-my-zsh" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Oh-My-Zsh already installed${RESET}"
  fi

  # Check for git config
  GIT_USER=$(git config --global user.name 2>/dev/null)
  GIT_EMAIL=$(git config --global user.email 2>/dev/null)

  if [ -n "$GIT_USER" ] && [ -n "$GIT_EMAIL" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git already configured:${RESET}"
    echo "   User:  $GIT_USER"
    echo "   Email: $GIT_EMAIL"
  fi

  # Check for stored credentials
  if [ -f "$HOME/.git-credentials" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git credentials already stored${RESET}"
  fi

  if [ "$SETUP_EXISTS" = true ]; then
    echo ""
    echo "${CYAN}${BOLD}==== UPDATE MODE ACTIVATED ====${RESET}"
    echo "${CYAN}Detected existing setup. Skipping installation steps.${RESET}"
    echo "${CYAN}Will proceed directly to repo sync...${RESET}"
    echo ""
    sleep 2
    SKIP_INSTALL=true
  else
    echo "${CYAN}${BOLD}==== INSTALL MODE ACTIVATED ====${RESET}"
    echo "${CYAN}Fresh installation detected.${RESET}"
    echo ""
    sleep 1
  fi
}

# --- PHASE 1 FUNCTIONS ---
print_box() {
  printf '%b\n' "${CYAN}┌─────────────────────────────────────────┐${RESET}"
  printf '%b\n' "${CYAN}│${BOLD} $1${RESET}${CYAN} │${RESET}"
  printf '%b\n' "${CYAN}├─────────────────────────────────────────┤${RESET}"
  printf "%s\n" "$2" | while IFS= read -r line; do
    printf '%b' "${CYAN}│ ${RESET}"
    printf '%-37s' "$line"
    printf '%b\n' "${CYAN} │${RESET}"
  done
  printf '%b\n' "${CYAN}└─────────────────────────────────────────┘${RESET}"
}

progress() {
  secs=${1:-1}
  printf '   [....................] (0%%)'
  sleep 0.2
  printf '\r   [#######.............] (35%%)'
  
  # Use awk if available, otherwise simple sleep
  if command -v awk >/dev/null 2>&1; then
    half=$(awk "BEGIN {printf \"%.2f\", $secs/2}")
  else
    half=$(echo "$secs" | sed 's/[^0-9.]//g')
    half=${half:-1}
  fi
  
  sleep "$half" 2>/dev/null || sleep 1
  printf '\r   [##############......] (70%%)'
  sleep "$half" 2>/dev/null || sleep 1
  printf '\r   [####################] (100%%) %b\n' "${GREEN}Done${RESET}"
}

# Install packages based on OS
install_packages() {
  detect_os
  print_box "Environment" "Detected: $OS$([ "$WSL" = true ] && echo " (WSL)")"

  case $OS in
    alpine)
      # iSH uses Alpine
      print_box "Step 1/3" "Installing System Dependencies (Alpine)..."
      apk update >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! apk add --no-cache build-base ncurses-dev git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    ubuntu|debian)
      # WSL typically uses Ubuntu
      print_box "Step 1/3" "Installing System Dependencies (Debian/Ubuntu)..."
      sudo apt-get update -qq >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! sudo apt-get install -qq -y build-essential git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    fedora|rhel|centos)
      print_box "Step 1/3" "Installing System Dependencies (RHEL/Fedora)..."
      if ! sudo dnf install -y -q git zsh jq curl gcc make bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    arch|manjaro)
      print_box "Step 1/3" "Installing System Dependencies (Arch)..."
      if ! sudo pacman -Sy --noconfirm git zsh jq curl base-devel bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    macos)
      print_box "Step 1/3" "Installing System Dependencies (macOS)..."
      # Check if Homebrew is installed
      if ! command -v brew >/dev/null 2>&1; then
        echo "${RED}Error: Homebrew not found. Install from https://brew.sh${RESET}"
        exit 1
      fi
      if ! brew install git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    *)
      echo "${RED}Error: Unsupported OS: $OS${RESET}"
      echo "Supported: Alpine (iSH), Ubuntu/Debian (WSL), Fedora, Arch, macOS"
      exit 1
      ;;
  esac
  progress 2
}

install_omz() {
  print_box "Step 2/3" "Installing Oh-My-Zsh..."
  if [ ! -d "$HOME/.oh-my-zsh" ]; then
    if ! sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended >/dev/null 2>&1; then
      echo "${RED}Error: Failed to install Oh-My-Zsh${RESET}"
      exit 1
    fi
  else
    echo "   ${GREEN}Oh-My-Zsh already installed. Skipping.${RESET}"
  fi
  progress 1
}

setup_zsh_default() {
  print_box "Step 3/3" "Setting Zsh as Default..."
  
  # Different approaches for different environments
  if [ "$WSL" = true ]; then
    # WSL: Update .bashrc to auto-switch to zsh
    if ! grep -q "exec zsh" ~/.bashrc 2>/dev/null; then
      echo '# Auto-start zsh' >> ~/.bashrc
      echo 'if [ -t 1 ]; then' >> ~/.bashrc
      echo '  exec zsh' >> ~/.bashrc
      echo 'fi' >> ~/.bashrc
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
    # Also change default shell if possible
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || true
    fi
  elif [ "$OS" = "alpine" ]; then
    # iSH: Use .profile
    if ! grep -q "exec zsh" ~/.profile 2>/dev/null; then
      echo '[ -z "$ZSH_VERSION" ] && exec zsh' >> ~/.profile
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
  else
    # Standard Linux/macOS: Change default shell
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      # Add zsh to /etc/shells if not present
      if ! grep -q "$ZSH_PATH" /etc/shells 2>/dev/null; then
        echo "$ZSH_PATH" | sudo tee -a /etc/shells >/dev/null
      fi
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || {
        echo "${RED}Warning: Could not change default shell${RESET}"
      }
    fi
  fi
  progress 0.5
}

# =====================================================
# EXECUTION: PHASE 1 (INSTALLATION)
# =====================================================
clear
check_existing_setup

# Determine if we should skip zsh-specific steps (Windows/WSL)
SKIP_ZSH_INSTALL=false
if [ "$OS" = "windows" ] || [ "$WSL" = true ]; then
  SKIP_ZSH_INSTALL=true
fi

# Only run installation if not already set up
if [ "$SKIP_INSTALL" = false ]; then
  install_packages
  if [ "$SKIP_ZSH_INSTALL" = false ]; then
    install_omz
    setup_zsh_default

    # Verify zsh is installed before handoff
    if ! command -v zsh >/dev/null 2>&1; then
      echo "${RED}Error: Zsh not found. Cannot proceed.${RESET}"
      exit 1
    fi
  else
    echo "${YELLOW}>> Skipping zsh/Oh-My-Zsh installation on Windows/WSL${RESET}"
  fi
else
  # In update mode
  if [ "$SKIP_ZSH_INSTALL" = false ]; then
    if ! command -v zsh >/dev/null 2>&1; then
      echo "${RED}Error: Zsh not found but .zshrc exists. Corrupted installation?${RESET}"
      exit 1
    fi
  else
    echo "${YELLOW}>> Running in Windows/WSL update mode: skipping zsh verification${RESET}"
  fi
  echo "${GREEN}>> Skipping to repository sync...${RESET}"
  sleep 1
fi

# =====================================================
# EXECUTION: PHASE 2 (INTERACTIVE REPO MANAGEMENT)
# =====================================================

clear
print_box "Phase 2" "Handoff & Repo Management"

echo ""
echo "${CYAN}_________________________________________${RESET}"
echo " STATIK_FINTECH // SYSTEM_HANDOFF"
echo "${CYAN}-----------------------------------------${RESET}"

# --- CHECK EXISTING GIT CONFIG ---
EXISTING_USER=$(git config --global user.name 2>/dev/null)
EXISTING_EMAIL=$(git config --global user.email 2>/dev/null)
HAS_CREDENTIALS=false
if [ -f "$HOME/.git-credentials" ]; then
  HAS_CREDENTIALS=true
fi

SKIP_GIT_CONFIG=false
if [ -n "$EXISTING_USER" ] && [ -n "$EXISTING_EMAIL" ] && [ "$HAS_CREDENTIALS" = true ]; then
  echo "${GREEN}>> EXISTING GIT CONFIGURATION DETECTED${RESET}"
  echo "   User:  $EXISTING_USER"
  echo "   Email: $EXISTING_EMAIL"
  echo "   Credentials: Stored"
  printf "${YELLOW}Use existing configuration? (y/n): ${RESET}"
  read -r USE_EXISTING
  if printf '%s' "$USE_EXISTING" | grep -qi '^y' >/dev/null 2>&1; then
    GH_USER="$EXISTING_USER"
    GH_EMAIL="$EXISTING_EMAIL"
    SKIP_GIT_CONFIG=true
  else
    SKIP_GIT_CONFIG=false
  fi
else
  SKIP_GIT_CONFIG=false
fi

if [ "$SKIP_GIT_CONFIG" = false ]; then
  echo ""
  printf "${BOLD}GitHub Username:${RESET} "
  read -r GH_USER
  if [ -z "$GH_USER" ]; then echo "${RED}Error: Username cannot be empty${RESET}"; exit 1; fi
  printf "${BOLD}GitHub Email:   ${RESET} "
  read -r GH_EMAIL
  if [ -z "$GH_EMAIL" ]; then echo "${RED}Error: Email cannot be empty${RESET}"; exit 1; fi
  printf "${BOLD}GitHub Token:   ${RESET} "
  read -s GH_TOKEN
  echo ""

  # --- APPLYING GIT CONFIG ---
  git config --global user.name "$GH_USER" || { echo "${RED}Error: Failed to set git username${RESET}"; exit 1; }
  git config --global user.email "$GH_EMAIL" || { echo "${RED}Error: Failed to set git email${RESET}"; exit 1; }
  git config --global credential.helper store

  if [ -n "$GH_USER" ] && [ -n "$GH_TOKEN" ]; then
    GH_USER_ENC=$(printf '%s' "$GH_USER" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    GH_TOKEN_ENC=$(printf '%s' "$GH_TOKEN" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    printf "https://%s:%s@github.com\n" "$GH_USER_ENC" "$GH_TOKEN_ENC" > "$HOME/.git-credentials"
    chmod 600 "$HOME/.git-credentials"
    printf "${GREEN}[ SUCCESS ] Credentials Encrypted & Stored.${RESET}\n"
  else
    printf "${YELLOW}[ WARNING ] Incomplete credentials. Skipping Auth write.${RESET}\n"
  fi
  sleep 1
fi

# Determine builds directory: prefer PWD/builds, fallback to HOME/builds, else create PWD/builds
if [ -d "$PWD/builds" ]; then
  BUILD_DIR="$PWD/builds"
elif [ -d "$HOME/builds" ]; then
  BUILD_DIR="$HOME/builds"
else
  BUILD_DIR="$PWD/builds"
  mkdir -p "$BUILD_DIR" || { echo "${RED}Error: Cannot create builds directory${RESET}"; exit 1; }
fi
cd "$BUILD_DIR" || { echo "${RED}Error: Cannot access builds directory${RESET}"; exit 1; }

# Extract token from credentials if not provided
if [ -z "$GH_TOKEN" ] && [ -f "$HOME/.git-credentials" ]; then
  GH_TOKEN=$(sed -n 's|.*https://[^:]*:\([^@]*\)@github.com.*|\1|p' "$HOME/.git-credentials" | head -n1 2>/dev/null || true)
fi

if [ -n "$GH_TOKEN" ]; then
  AUTH_HEADER="Authorization: token $GH_TOKEN"
else
  AUTH_HEADER="User-Agent: statik-bot"
fi

API_USER="${GH_USER:-$EXISTING_USER}"
if [ -z "$API_USER" ]; then echo "${RED}Error: No GitHub username available${RESET}"; exit 1; fi

JSON_DATA=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/users/$API_USER/repos?per_page=200")

# Ensure jq is available or prompt to install; otherwise fall back to simple parsing
USE_JQ=true
if ! command -v jq >/dev/null 2>&1; then
  printf "${YELLOW}Note: 'jq' is required to parse GitHub JSON efficiently and was not found. Install now? (y/n): ${RESET}"
  read -r INSTALL_JQ
  if printf '%s' "$INSTALL_JQ" | grep -qi '^y' >/dev/null 2>&1; then
    case $OS in
      alpine)
        apk update >/dev/null 2>&1 || true
        if ! apk add --no-cache jq >/dev/null 2>&1; then
          echo "${RED}Failed to install jq${RESET}"
          USE_JQ=false
        fi
        ;;
      ubuntu|debian)
        if command -v sudo >/dev/null 2>&1; then
          sudo apt-get update -qq >/dev/null 2>&1 || true
          sudo apt-get install -qq -y jq >/dev/null 2>&1 || { echo "${RED}Failed to install jq${RESET}"; USE_JQ=false; }
        else
          echo "${RED}Cannot install jq without sudo. Please install jq and rerun.${RESET}"
          USE_JQ=false
        fi
        ;;
      macos)
        if command -v brew >/dev/null 2>&1; then
          brew install jq >/dev/null 2>&1 || { echo "${RED}Failed to install jq${RESET}"; USE_JQ=false; }
        else
          echo "${RED}Homebrew not found. Cannot install jq automatically.${RESET}"
          USE_JQ=false
        fi
        ;;
      *)
        echo "${YELLOW}Automatic jq installation is not supported on this OS.${RESET}"
        USE_JQ=false
        ;;
    esac
  else
    echo "${YELLOW}Proceeding without jq; will attempt fallback parsing.${RESET}"
    USE_JQ=false
  fi
fi

if [ "$USE_JQ" = true ]; then
  IS_VALID=$(echo "$JSON_DATA" | jq -r 'if type=="array" then "yes" else "no" end' 2>/dev/null)
  if [ "$IS_VALID" != "yes" ]; then
    echo "${RED}[ ERROR ] Unable to fetch repos. Check Token or API Status.${RESET}"
    ERROR_MSG=$(echo "$JSON_DATA" | jq -r '.message // "Unknown error"' 2>/dev/null)
    echo "API Response: $ERROR_MSG"
    exit 1
  fi
  echo "$JSON_DATA" | jq -r '.[] | "\(.name)|\(.clone_url)"' > /tmp/statik_repos.txt
  TOTAL_REPOS=$(wc -l < /tmp/statik_repos.txt | tr -d ' ')
  if [ "${TOTAL_REPOS:-0}" -eq 0 ]; then echo "${YELLOW}>> NO REPOSITORIES FOUND${RESET}"; exit 0; fi
  printf "\r${YELLOW}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n"
else
  # Fallback parsing without jq (best-effort)
  rm -f /tmp/statik_repos.txt
  name=""
  url=""
  echo "$JSON_DATA" | tr ',' '\n' | while IFS= read -r line; do
    if printf "%s" "$line" | grep -q '"name"'; then
      name=$(printf "%s" "$line" | sed -n 's/.*"name":[[:space:]]*"\([^"]*\)".*/\1/p')
    fi
    if printf "%s" "$line" | grep -q '"clone_url"'; then
      url=$(printf "%s" "$line" | sed -n 's/.*"clone_url":[[:space:]]*"\([^"]*\)".*/\1/p')
    fi
    if [ -n "$name" ] && [ -n "$url" ]; then
      printf "%s|%s\n" "$name" "$url" >> /tmp/statik_repos.txt
      name=""
      url=""
    fi
  done
  TOTAL_REPOS=$(wc -l < /tmp/statik_repos.txt | tr -d ' ')
  if [ "${TOTAL_REPOS:-0}" -eq 0 ]; then echo "${YELLOW}>> NO REPOSITORIES FOUND (fallback parsing)${RESET}"; exit 0; fi
  printf "\r${YELLOW}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n"
fi

get_repo_line() { sed -n "${1}p" /tmp/statik_repos.txt; }

do_clone() {
  name="$1"; url="$2"
  if [ -d "$name/.git" ]; then echo "${YELLOW}>> $name already exists. Skipping clone.${RESET}"; return; fi
  echo "${CYAN}Cloning $name...${RESET}"
  if git clone "$url" "$name" >/dev/null 2>&1; then echo "${GREEN}Cloned $name${RESET}"; else echo "${RED}Failed to clone $name${RESET}"; fi
}

do_update() {
  name="$1"
  if [ ! -d "$name/.git" ]; then echo "${YELLOW}>> $name is not present. Use install first.${RESET}"; return; fi
  echo "${CYAN}Updating $name...${RESET}"
  (cd "$name" && git pull --ff-only) >/dev/null 2>&1 && echo "${GREEN}Updated $name${RESET}" || echo "${YELLOW}No changes or update failed for $name${RESET}"
}

do_status() {
  name="$1"
  if [ ! -d "$name/.git" ]; then echo "${YELLOW}>> $name is not present.${RESET}"; return; fi
  echo "${CYAN}Status for $name:${RESET}"
  (cd "$name" && git status --short) || echo "${RED}Failed to show status for $name${RESET}"
}

do_commit() {
  name="$1"
  if [ ! -d "$name/.git" ]; then echo "${YELLOW}>> $name is not present.${RESET}"; return; fi
  echo "${CYAN}Enter commit message for $name:${RESET}"
  read -r CM
  if [ -z "$CM" ]; then echo "${YELLOW}No message provided. Skipping commit.${RESET}"; return; fi
  (cd "$name" && git add -A && git commit -m "$CM" >/dev/null 2>&1 && git push) && echo "${GREEN}Committed & pushed in $name${RESET}" || echo "${YELLOW}Nothing to commit or push failed in $name${RESET}"
}

do_delete() {
  name="$1"
  echo "${RED}Confirm delete of ${name}? Type 'yes' to confirm:${RESET}"
  read -r CONF
  if [ "$CONF" = "yes" ]; then rm -rf "$name" && echo "${GREEN}Deleted $name${RESET}" || echo "${RED}Failed to delete $name${RESET}"; else echo "${YELLOW}Aborted delete of $name${RESET}"; fi
}

count=0
while IFS='|' read -r rname rurl; do
  count=$((count + 1))
  printf '%b\n' "${CYAN}-----------------------------------------${RESET}"
  printf '%b' "${BOLD}Target ${count}/${TOTAL_REPOS}:${RESET} "
  printf '%b\n' "${rname}"

  if [ -d "$rname/.git" ]; then
    printf '%b\n' "${GREEN}Status: Present${RESET}"
  else
    printf '%b\n' "${YELLOW}Status: Not present${RESET}"
  fi

  # Per-repo interactive prompt: allows status then user can choose action
  while true; do
    printf '%b' "${YELLOW}Action for ${rname} [i=install u=update s=status c=commit d=delete p=pass q=quit]: ${RESET}"
    read -r REPLY_ACTION
    case "$REPLY_ACTION" in
      i)
        do_clone "$rname" "$rurl"
        break
        ;;
      u)
        do_update "$rname"
        break
        ;;
      s)
        do_status "$rname"
        ;;
      c)
        do_commit "$rname"
        break
        ;;
      d)
        do_delete "$rname"
        break
        ;;
      p)
        printf '%b\n' "${CYAN}Skipping ${rname}${RESET}"
        break
        ;;
      q)
        printf '%b\n' "${GREEN}Exiting interactive manager.${RESET}"
        exit 0
        ;;
      *)
        printf '%b\n' "${YELLOW}Unknown action: ${REPLY_ACTION}${RESET}"
        ;;
    esac
  done
done < /tmp/statik_repos.txt

echo "${GREEN}All tasks complete. Repositories located at: ${BUILD_DIR}${RESET}"
if [ -n "$WSL_DISTRO_NAME" ]; then
  echo "(Access from Windows: \\wsl\\${WSL_DISTRO_NAME}${BUILD_DIR})"
fi
sleep 1
