#!/bin/sh
# =====================================================
# STATIKFINTECHLLC // MASTER_BOOTSTRAP (UNIVERSAL)
# Compatible: iSH (iOS), WSL (Windows), Linux, macOS
# Smart Detection: Install or Update Mode
# Phase 1: Environment Setup (sh/cyan)
# Phase 2: Credentials & Sync (zsh/red)
# =====================================================

# --- PHASE 1 COLORS (Cyan Theme) ---
CYAN='\033[36m'
GREEN='\033[32m'
YELLOW='\033[1;33m'
RED='\033[0;31m'
BOLD='\033[1m'
RESET='\033[0m'

# --- DETECT ENVIRONMENT ---
detect_os() {
  if [ -f /etc/os-release ]; then
    . /etc/os-release
    OS=$ID
  elif [ "$(uname)" = "Darwin" ]; then
    OS="macos"
  else
    OS="unknown"
  fi

  # Check if running in WSL
  if grep -qi microsoft /proc/version 2>/dev/null; then
    WSL=true
  else
    WSL=false
  fi
}

# --- CHECK IF ALREADY INSTALLED ---
check_existing_setup() {
  SETUP_EXISTS=false
  SKIP_INSTALL=false

  # Check for .zshrc (indicates Oh-My-Zsh is configured)
  if [ -f "$HOME/.zshrc" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Existing .zshrc detected${RESET}"
  fi

  # Check for Oh-My-Zsh
  if [ -d "$HOME/.oh-my-zsh" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Oh-My-Zsh already installed${RESET}"
  fi

  # Check for git config
  GIT_USER=$(git config --global user.name 2>/dev/null)
  GIT_EMAIL=$(git config --global user.email 2>/dev/null)

  if [ -n "$GIT_USER" ] && [ -n "$GIT_EMAIL" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git already configured:${RESET}"
    echo "   User:  $GIT_USER"
    echo "   Email: $GIT_EMAIL"
  fi

  # Check for stored credentials
  if [ -f "$HOME/.git-credentials" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git credentials already stored${RESET}"
  fi

  if [ "$SETUP_EXISTS" = true ]; then
    echo ""
    # If zsh is present, treat as update mode; otherwise attempt repair by reinstalling missing components
    if command -v zsh >/dev/null 2>&1; then
      echo "${CYAN}${BOLD}==== UPDATE MODE ACTIVATED ====${RESET}"
      echo "${CYAN}Detected existing setup. Skipping installation steps.${RESET}"
      echo "${CYAN}Will proceed directly to repo sync...${RESET}"
      echo ""
      sleep 2
      SKIP_INSTALL=true
    else
      echo "${CYAN}${BOLD}==== PARTIAL SETUP DETECTED ====${RESET}"
      echo "${YELLOW}Detected existing configuration files but Zsh is missing.${RESET}"
      echo "${CYAN}Attempting to repair and install missing components...${RESET}"
      echo ""
      sleep 2
      SKIP_INSTALL=false
    fi
  else
    echo "${CYAN}${BOLD}==== INSTALL MODE ACTIVATED ====${RESET}"
    echo "${CYAN}Fresh installation detected.${RESET}"
    echo ""
    sleep 1
  fi
}

# --- PHASE 1 FUNCTIONS ---
print_box() {
  echo "${CYAN}┌─────────────────────────────────────────┐${RESET}"
  echo "${CYAN}│${BOLD} $1${RESET}${CYAN} │${RESET}"
  echo "${CYAN}├─────────────────────────────────────────┤${RESET}"
  printf "%s\n" "$2" | while IFS= read -r line; do
    printf "${CYAN}│ ${RESET}%-37s${CYAN} │${RESET}\n" "$line"
  done
  echo "${CYAN}└─────────────────────────────────────────┘${RESET}"
}

progress() {
  secs=${1:-1}
  echo -ne "   [....................] (0%)"
  sleep 0.2
  echo -ne "\r   [#######.............] (35%)"
  
  # Use awk if available, otherwise simple sleep
  if command -v awk >/dev/null 2>&1; then
    half=$(awk "BEGIN {printf \"%.2f\", $secs/2}")
  else
    half=$(echo "$secs" | sed 's/[^0-9.]//g')
    half=${half:-1}
  fi
  
  sleep "$half" 2>/dev/null || sleep 1
  echo -ne "\r   [##############......] (70%)"
  sleep "$half" 2>/dev/null || sleep 1
  echo -e "\r   [####################] (100%) ${GREEN}Done${RESET}"
}

# Install packages based on OS
install_packages() {
  detect_os
  print_box "Environment" "Detected: $OS$([ "$WSL" = true ] && echo " (WSL)")"

  case $OS in
    alpine)
      # iSH uses Alpine
      print_box "Step 1/3" "Installing System Dependencies (Alpine)..."
      apk update >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! apk add --no-cache build-base ncurses-dev git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    ubuntu|debian)
      # WSL typically uses Ubuntu
      print_box "Step 1/3" "Installing System Dependencies (Debian/Ubuntu)..."
      sudo apt-get update -qq >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! sudo apt-get install -qq -y build-essential git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    fedora|rhel|centos)
      print_box "Step 1/3" "Installing System Dependencies (RHEL/Fedora)..."
      if ! sudo dnf install -y -q git zsh jq curl gcc make bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    arch|manjaro)
      print_box "Step 1/3" "Installing System Dependencies (Arch)..."
      if ! sudo pacman -Sy --noconfirm git zsh jq curl base-devel bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    macos)
      print_box "Step 1/3" "Installing System Dependencies (macOS)..."
      # Check if Homebrew is installed
      if ! command -v brew >/dev/null 2>&1; then
        echo "${RED}Error: Homebrew not found. Install from https://brew.sh${RESET}"
        exit 1
      fi
      if ! brew install git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    *)
      echo "${RED}Error: Unsupported OS: $OS${RESET}"
      echo "Supported: Alpine (iSH), Ubuntu/Debian (WSL), Fedora, Arch, macOS"
      exit 1
      ;;
  esac
  progress 2
}

install_omz() {
  print_box "Step 2/3" "Installing Oh-My-Zsh..."
  if [ ! -d "$HOME/.oh-my-zsh" ]; then
    if ! sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended >/dev/null 2>&1; then
      echo "${RED}Error: Failed to install Oh-My-Zsh${RESET}"
      exit 1
    fi
  else
    echo "   ${GREEN}Oh-My-Zsh already installed. Skipping.${RESET}"
  fi
  progress 1
}

setup_zsh_default() {
  print_box "Step 3/3" "Setting Zsh as Default..."
  
  # Different approaches for different environments
  if [ "$WSL" = true ]; then
    # WSL: Update .bashrc to auto-switch to zsh
    if ! grep -q "exec zsh" ~/.bashrc 2>/dev/null; then
      echo '# Auto-start zsh' >> ~/.bashrc
      echo 'if [ -t 1 ]; then' >> ~/.bashrc
      echo '  exec zsh' >> ~/.bashrc
      echo 'fi' >> ~/.bashrc
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
    # Also change default shell if possible
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || true
    fi
  elif [ "$OS" = "alpine" ]; then
    # iSH: Use .profile
    if ! grep -q "exec zsh" ~/.profile 2>/dev/null; then
      echo '[ -z "$ZSH_VERSION" ] && exec zsh' >> ~/.profile
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
  else
    # Standard Linux/macOS: Change default shell
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      # Add zsh to /etc/shells if not present
      if ! grep -q "$ZSH_PATH" /etc/shells 2>/dev/null; then
        echo "$ZSH_PATH" | sudo tee -a /etc/shells >/dev/null
      fi
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || {
        echo "${RED}Warning: Could not change default shell${RESET}"
      }
    fi
  fi
  progress 0.5
}

# =====================================================
# EXECUTION: PHASE 1 (INSTALLATION)
# =====================================================
clear
check_existing_setup

# Only run installation if not already set up
if [ "$SKIP_INSTALL" = false ]; then
  install_packages
  install_omz
  setup_zsh_default
  
  # Verify zsh is installed before handoff
  if ! command -v zsh >/dev/null 2>&1; then
    echo "${RED}Error: Zsh not found after installation steps. Repair attempt failed.${RESET}"
    echo "${YELLOW}Tip: Try installing zsh manually (e.g., 'sudo apt-get install zsh' or use your distro's package manager), then re-run this installer.${RESET}"
    echo "${CYAN}If problems persist, inspect /tmp/installer.log for details.${RESET}"
    exit 1
  fi
else
  # In update mode, just verify zsh exists
  if ! command -v zsh >/dev/null 2>&1; then
    echo "${RED}Error: Zsh not found but .zshrc exists. Possible corrupted installation.${RESET}"
    echo "${YELLOW}Tip: Re-run the installer to attempt repair (this will try to reinstall missing components).${RESET}"
    echo "${CYAN}If you prefer manual repair, install zsh and then re-run this script.${RESET}"
    exit 1
  fi
  echo "${GREEN}>> Skipping to repository sync...${RESET}"
  sleep 1
fi

# =====================================================
# EXECUTION: PHASE 2 (HANDOFF TO ZSH)
# =====================================================

cat << 'ZSHEOF' > /tmp/statik_sync_core.zsh
#!/bin/zsh

# --- PHASE 2 COLORS (Red Theme) ---
RED='\033[0;31m'
B_RED='\033[1;31m'
DARK='\033[2;31m'
GOLD='\033[1;33m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
RESET='\033[0m'

clear
# Digital Rain Header
echo "${DARK}"
cat << "HEADER"
 _________________________________________
|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|
 STATIK_FINTECH // SYSTEM_HANDOFF
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
HEADER
echo "${RESET}"

# --- CHECK EXISTING GIT CONFIG ---
EXISTING_USER=$(git config --global user.name 2>/dev/null)
EXISTING_EMAIL=$(git config --global user.email 2>/dev/null)
HAS_CREDENTIALS=false

if [ -f "$HOME/.git-credentials" ]; then
  HAS_CREDENTIALS=true
fi

# --- GIT CONFIGURATION UI ---
if [ -n "$EXISTING_USER" ] && [ -n "$EXISTING_EMAIL" ] && [ "$HAS_CREDENTIALS" = true ]; then
  echo "${GREEN}>> EXISTING GIT CONFIGURATION DETECTED${RESET}"
  echo "${DARK}   User:  ${RESET}$EXISTING_USER"
  echo "${DARK}   Email: ${RESET}$EXISTING_EMAIL"
  echo "${GREEN}   Credentials: ${RESET}Stored"
  echo ""
  printf "${YELLOW}Use existing configuration? (y/n): ${RESET}"
  read -r USE_EXISTING
  echo ""
  
  if [[ "$USE_EXISTING" =~ ^[Yy]$ ]]; then
    echo "${GREEN}>> Using existing GitHub configuration${RESET}"
    GH_USER="$EXISTING_USER"
    GH_EMAIL="$EXISTING_EMAIL"
    SKIP_GIT_CONFIG=true
  else
    echo "${B_RED}>> RECONFIGURING CREDENTIALS...${RESET}"
    SKIP_GIT_CONFIG=false
  fi
else
  echo "${B_RED}>> INITIALIZING CREDENTIAL PROTOCOL...${RESET}"
  SKIP_GIT_CONFIG=false
fi

if [ "$SKIP_GIT_CONFIG" = false ]; then
  echo ""
  echo "${DARK}Please enter GitHub Identity for Global Config:${RESET}"
  
  # 1. Username
  printf "${B_RED}GitHub Username:${RESET} "
  read GH_USER
  # Basic validation
  if [ -z "$GH_USER" ]; then
    echo "${RED}Error: Username cannot be empty${RESET}"
    exit 1
  fi
  
  # 2. Email (Crucial for commits)
  printf "${B_RED}GitHub Email:   ${RESET} "
  read GH_EMAIL
  if [ -z "$GH_EMAIL" ]; then
    echo "${RED}Error: Email cannot be empty${RESET}"
    exit 1
  fi
  
  # 3. Token
  printf "${B_RED}GitHub Token:   ${RESET} "
  read -s GH_TOKEN
  echo ""
  echo ""
  
  if [ -z "$GH_TOKEN" ]; then
    echo "${RED}Warning: No token provided. API rate limits will apply.${RESET}"
    sleep 2
  fi
  
  # --- APPLYING GIT CONFIG ---
  echo "${DARK}>> WRITING CONFIGURATION...${RESET}"
  
  # Set Global Name/Email
  git config --global user.name "$GH_USER" || {
    echo "${RED}Error: Failed to set git username${RESET}"
    exit 1
  }
  
  git config --global user.email "$GH_EMAIL" || {
    echo "${RED}Error: Failed to set git email${RESET}"
    exit 1
  }
  
  # Set Credential Helper (Store allows permanent login)
  git config --global credential.helper store
  
  # Create credentials file properly with URL encoding
  if [ -n "$GH_USER" ] && [ -n "$GH_TOKEN" ]; then
    # More comprehensive encoding
    GH_USER_ENC=$(printf '%s' "$GH_USER" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    GH_TOKEN_ENC=$(printf '%s' "$GH_TOKEN" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    
    # Write to ~/.git-credentials with explicit newline
    printf "https://%s:%s@github.com\n" "$GH_USER_ENC" "$GH_TOKEN_ENC" > ~/.git-credentials
    chmod 600 ~/.git-credentials
    printf "${GOLD}[ SUCCESS ] Credentials Encrypted & Stored.${RESET}\n"
  else
    printf "${RED}[ WARNING ] Incomplete credentials. Skipping Auth write.${RESET}\n"
  fi
  sleep 1
fi

# =====================================================
# EXECUTION: PHASE 3 (REPO SYNC)
# =====================================================

# Spinner Function with better process handling
spinner() {
    local pid=$1
    local msg=$2
    local delay=0.1
    local spinstr='⣾⣽⣻⢿⡿⣟⣯⣷' 
    local i=0
    
    while kill -0 "$pid" 2>/dev/null; do
        i=$(( (i+1) % 8 ))
        printf "\r${DARK}%-20s${B_RED} [ %s ]${RESET}" "$msg" "${spinstr:$i:1}"
        sleep $delay
    done
    
    # Wait for process to fully complete
    wait "$pid" 2>/dev/null
    return $?
}

printf "\n${B_RED}>> ENGAGING REPO SYNC ENGINE...${RESET}\n"

# Determine home directory for builds
# WSL can use Windows home or Linux home - prefer Linux
if [ -n "$WSL_DISTRO_NAME" ]; then
    BUILD_DIR="$HOME/builds"
else
    BUILD_DIR="$HOME/builds"
fi

# Create builds directory if it doesn't exist and enter it
if [ ! -d "$BUILD_DIR" ]; then
    mkdir -p "$BUILD_DIR" || {
        echo "${RED}Error: Cannot create builds directory${RESET}"
        exit 1
    }
fi
cd "$BUILD_DIR" || {
    echo "${RED}Error: Cannot access builds directory${RESET}"
    exit 1
}

# Extract token from credentials if not provided
if [ -z "$GH_TOKEN" ] && [ -f "$HOME/.git-credentials" ]; then
    # Try to extract token from stored credentials
    GH_TOKEN=$(grep 'github.com' "$HOME/.git-credentials" | sed -n 's/.*://[^:]*:\([^@]*\)@.*/\1/p' | head -1)
fi

# Use the token for the API call (Avoids API limits)
if [ -n "$GH_TOKEN" ]; then
    AUTH_HEADER="Authorization: token $GH_TOKEN"
else
    AUTH_HEADER="User-Agent: statik-bot"
fi

# Use configured git user for API call
API_USER="${GH_USER:-$EXISTING_USER}"

if [ -z "$API_USER" ]; then
    echo "${RED}Error: No GitHub username available${RESET}"
    exit 1
fi

JSON_DATA=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/users/$API_USER/repos?per_page=100")

# Check if we got valid JSON or an error
IS_VALID=$(echo "$JSON_DATA" | jq -r 'if type=="array" then "yes" else "no" end' 2>/dev/null)

if [ "$IS_VALID" != "yes" ]; then
    echo "${RED}[ ERROR ] Unable to fetch repos. Check Token or API Status.${RESET}"
    ERROR_MSG=$(echo "$JSON_DATA" | jq -r '.message // "Unknown error"' 2>/dev/null)
    echo "API Response: $ERROR_MSG"
    exit 1
fi

# Get repo list and filter empty lines
REPO_LIST=$(echo "$JSON_DATA" | jq -r '.[].clone_url' | grep -v '^$')
TOTAL_REPOS=$(echo "$REPO_LIST" | wc -l | tr -d ' ')

# Handle case of no repos
if [ "$TOTAL_REPOS" -eq 0 ] || [ -z "$REPO_LIST" ]; then
    echo "${GOLD}>> NO REPOSITORIES FOUND${RESET}"
    exit 0
fi

printf "\r${GOLD}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n"

# Process repos with proper COUNT tracking
COUNT=1
CLONED=0
UPDATED=0
FAILED=0

while IFS= read -r repo; do
    [ -z "$repo" ] && continue
    dir=$(basename "$repo" .git)
    PROGRESS_TAG="[$(printf "%02d" $COUNT)/$TOTAL_REPOS]"

    if [ -d "$dir/.git" ]; then
        # UPDATE
        (cd "$dir" && git pull --ff-only 2>&1 | grep -v "Already up to date" || true) >/dev/null &
        PID=$!
        spinner $PID "$dir"
        EXIT_CODE=$?
        
        if [ $EXIT_CODE -eq 0 ]; then
            printf "\r${DARK}%-20s${RESET} ${GOLD}[ UPDATED ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
            UPDATED=$((UPDATED + 1))
        else
            printf "\r${DARK}%-20s${RESET} ${RED}[ FAILED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
            FAILED=$((FAILED + 1))
        fi
    else
        # CLONE
        git clone "$repo" "$dir" >/dev/null 2>&1 &
        PID=$!
        spinner $PID "$dir"
        EXIT_CODE=$?
        
        if [ $EXIT_CODE -eq 0 ]; then
            printf "\r${B_RED}%-20s${RESET} ${GOLD}[ CLONED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
            CLONED=$((CLONED + 1))
        else
            printf "\r${B_RED}%-20s${RESET} ${RED}[ FAILED  ] ${DARK}$PROGRESS_TAG${RESET}\n" "$dir"
            FAILED=$((FAILED + 1))
            # Clean up failed clone
            [ -d "$dir" ] && rm -rf "$dir"
        fi
    fi
    COUNT=$((COUNT + 1))
done < <(echo "$REPO_LIST")

echo ""
echo "${DARK}-----------------------------------------"
echo "${B_RED}  SYNC COMPLETE"
echo "${DARK}-----------------------------------------${RESET}"
echo "${GOLD}  Cloned:  ${CLONED}${RESET}"
echo "${GOLD}  Updated: ${UPDATED}${RESET}"
[ $FAILED -gt 0 ] && echo "${RED}  Failed:  ${FAILED}${RESET}"
echo "${DARK}-----------------------------------------${RESET}"
echo ""
echo "${GOLD}Repos located at: ${BUILD_DIR}${RESET}"

# WSL-specific tip
if [ -n "$WSL_DISTRO_NAME" ]; then
    echo "${DARK}(Access from Windows: \\\\wsl\$\\${WSL_DISTRO_NAME}${BUILD_DIR})${RESET}"
fi

sleep 2
ZSHEOF

# Make the ZSH script executable
chmod +x /tmp/statik_sync_core.zsh

# Execute Phase 2
exec zsh /tmp/statik_sync_core.zsh
