#!/bin/sh
# =====================================================
# STATIKFINTECHLLC // MASTER_BOOTSTRAP (UNIVERSAL)
# Compatible: iSH (iOS), WSL (Windows), Linux, macOS
# Smart Detection: Install or Update Mode
# Phase 1: Environment Setup (sh/cyan)
# Phase 2: Credentials & Sync (zsh/red)
# =====================================================

# --- PHASE 1 COLORS (Cyan Theme) ---
ESC=$(printf '\033')
CYAN="${ESC}[36m"
GREEN="${ESC}[32m"
YELLOW="${ESC}[1;33m"
RED="${ESC}[0;31m"
BOLD="${ESC}[1m"
RESET="${ESC}[0m"

# --- DETECT ENVIRONMENT ---
detect_os() {
  uname_s=$(uname -s 2>/dev/null || echo Unknown)
  case "$uname_s" in
    *MINGW*|*MSYS*|*CYGWIN*|*Windows_NT*)
      OS="windows"
      ;;
    Darwin*)
      OS="macos"
      ;;
    *)
      if [ -f /etc/os-release ]; then
        . /etc/os-release
        OS=$ID
      else
        OS="unknown"
      fi
      ;;
  esac

  # Check if running in WSL
  if [ -f /proc/version ] && grep -qi microsoft /proc/version 2>/dev/null; then
    WSL=true
  else
    WSL=false
  fi
}

# --- CHECK IF ALREADY INSTALLED ---
check_existing_setup() {
  SETUP_EXISTS=false
  SKIP_INSTALL=false

  # Check for .zshrc (indicates Oh-My-Zsh is configured)
  if [ -f "$HOME/.zshrc" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Existing .zshrc detected${RESET}"
  fi

  # Check for Oh-My-Zsh
  if [ -d "$HOME/.oh-my-zsh" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Oh-My-Zsh already installed${RESET}"
  fi

  # Check for git config
  GIT_USER=$(git config --global user.name 2>/dev/null)
  GIT_EMAIL=$(git config --global user.email 2>/dev/null)

  if [ -n "$GIT_USER" ] && [ -n "$GIT_EMAIL" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git already configured:${RESET}"
    echo "   User:  $GIT_USER"
    echo "   Email: $GIT_EMAIL"
  fi

  # Check for stored credentials
  if [ -f "$HOME/.git-credentials" ]; then
    SETUP_EXISTS=true
    echo "${YELLOW}>> Git credentials already stored${RESET}"
  fi

  if [ "$SETUP_EXISTS" = true ]; then
    echo ""
    echo "${CYAN}${BOLD}==== UPDATE MODE ACTIVATED ====${RESET}"
    echo "${CYAN}Detected existing setup. Skipping installation steps.${RESET}"
    echo "${CYAN}Will proceed directly to repo sync...${RESET}"
    echo ""
    sleep 2
    SKIP_INSTALL=true
  else
    echo "${CYAN}${BOLD}==== INSTALL MODE ACTIVATED ====${RESET}"
    echo "${CYAN}Fresh installation detected.${RESET}"
    echo ""
    sleep 1
  fi
}

# --- PHASE 1 FUNCTIONS ---
print_box() {
  printf '%b\n' "${CYAN}┌─────────────────────────────────────────┐${RESET}"
  printf '%b\n' "${CYAN}│${BOLD} $1${RESET}${CYAN} │${RESET}"
  printf '%b\n' "${CYAN}├─────────────────────────────────────────┤${RESET}"
  printf "%s\n" "$2" | while IFS= read -r line; do
    printf '%b' "${CYAN}│ ${RESET}"
    printf '%-37s' "$line"
    printf '%b\n' "${CYAN} │${RESET}"
  done
  printf '%b\n' "${CYAN}└─────────────────────────────────────────┘${RESET}"
}

start_blackout() {
  BLACKOUT_STARTED=true
  # Set pitch-black background and clear screen
  printf '\033[40m\033[2J\033[H'
  # Ensure terminal is reset if script exits unexpectedly
  trap 'printf "\033[0m"; clear; exit 1' INT TERM EXIT
}

end_blackout() {
  if [ "${BLACKOUT_STARTED}" = true ]; then
    printf '\033[0m'
    clear
    BLACKOUT_STARTED=false
    trap - INT TERM EXIT
  fi
}

progress() {
  secs=${1:-1}
  printf '   [....................] (0%%)'
  sleep 0.2
  printf '\r   [#######.............] (35%%)'
  
  # Use awk if available, otherwise simple sleep
  if command -v awk >/dev/null 2>&1; then
    half=$(awk "BEGIN {printf \"%.2f\", $secs/2}")
  else
    half=$(echo "$secs" | sed 's/[^0-9.]//g')
    half=${half:-1}
  fi
  
  sleep "$half" 2>/dev/null || sleep 1
  printf '\r   [##############......] (70%%)'
  sleep "$half" 2>/dev/null || sleep 1
  printf '\r   [####################] (100%%) %b\n' "${GREEN}Done${RESET}"
}

# Install packages based on OS
install_packages() {
  detect_os
  print_box "Environment" "Detected: $OS$([ "$WSL" = true ] && echo " (WSL)")"

  case $OS in
    alpine)
      # iSH uses Alpine
      print_box "Step 1/3" "Installing System Dependencies (Alpine)..."
      apk update >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! apk add --no-cache build-base ncurses-dev git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    ubuntu|debian)
      # WSL typically uses Ubuntu
      print_box "Step 1/3" "Installing System Dependencies (Debian/Ubuntu)..."
      sudo apt-get update -qq >/dev/null 2>&1 || {
        echo "${RED}Error: Failed to update package index${RESET}"
        exit 1
      }
      if ! sudo apt-get install -qq -y build-essential git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    fedora|rhel|centos)
      print_box "Step 1/3" "Installing System Dependencies (RHEL/Fedora)..."
      if ! sudo dnf install -y -q git zsh jq curl gcc make bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    arch|manjaro)
      print_box "Step 1/3" "Installing System Dependencies (Arch)..."
      if ! sudo pacman -Sy --noconfirm git zsh jq curl base-devel bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    macos)
      print_box "Step 1/3" "Installing System Dependencies (macOS)..."
      # Check if Homebrew is installed
      if ! command -v brew >/dev/null 2>&1; then
        echo "${RED}Error: Homebrew not found. Install from https://brew.sh${RESET}"
        exit 1
      fi
      if ! brew install git zsh jq curl bc >/dev/null 2>&1; then
        echo "${RED}Error: Failed to install dependencies${RESET}"
        exit 1
      fi
      ;;
      
    *)
      echo "${RED}Error: Unsupported OS: $OS${RESET}"
      echo "Supported: Alpine (iSH), Ubuntu/Debian (WSL), Fedora, Arch, macOS"
      exit 1
      ;;
  esac
  progress 2
}

install_omz() {
  print_box "Step 2/3" "Installing Oh-My-Zsh..."
  if [ ! -d "$HOME/.oh-my-zsh" ]; then
    if ! sh -c "$(curl -fsSL https://raw.githubusercontent.com/ohmyzsh/ohmyzsh/master/tools/install.sh)" "" --unattended >/dev/null 2>&1; then
      echo "${RED}Error: Failed to install Oh-My-Zsh${RESET}"
      exit 1
    fi
  else
    echo "   ${GREEN}Oh-My-Zsh already installed. Skipping.${RESET}"
  fi
  progress 1
}

setup_zsh_default() {
  print_box "Step 3/3" "Setting Zsh as Default..."
  
  # Different approaches for different environments
  if [ "$WSL" = true ]; then
    # WSL: Update .bashrc to auto-switch to zsh
    if ! grep -q "exec zsh" ~/.bashrc 2>/dev/null; then
      echo '# Auto-start zsh' >> ~/.bashrc
      echo 'if [ -t 1 ]; then' >> ~/.bashrc
      echo '  exec zsh' >> ~/.bashrc
      echo 'fi' >> ~/.bashrc
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
    # Also change default shell if possible
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || true
    fi
  elif [ "$OS" = "alpine" ]; then
    # iSH: Use .profile
    if ! grep -q "exec zsh" ~/.profile 2>/dev/null; then
      echo '[ -z "$ZSH_VERSION" ] && exec zsh' >> ~/.profile
    else
      echo "   ${GREEN}Zsh auto-start already configured.${RESET}"
    fi
  else
    # Standard Linux/macOS: Change default shell
    if command -v chsh >/dev/null 2>&1; then
      ZSH_PATH=$(command -v zsh)
      # Add zsh to /etc/shells if not present
      if ! grep -q "$ZSH_PATH" /etc/shells 2>/dev/null; then
        echo "$ZSH_PATH" | sudo tee -a /etc/shells >/dev/null
      fi
      sudo chsh -s "$ZSH_PATH" "$USER" 2>/dev/null || {
        echo "${RED}Warning: Could not change default shell${RESET}"
      }
    fi
  fi
  progress 0.5
}

# =====================================================
# EXECUTION: PHASE 1 (INSTALLATION)
# =====================================================
# Detect OS early so we can decide whether to blackout and skip zsh checks
detect_os
clear
# Blackout only for iSH (alpine) and when not running under WSL
if [ "${OS}" = "alpine" ] && [ "${WSL}" != true ]; then
  if command -v start_blackout >/dev/null 2>&1; then
    start_blackout
  fi
fi
check_existing_setup

# Determine if we should skip zsh-specific steps (Windows/WSL)
SKIP_ZSH_INSTALL=false
if [ "$OS" = "windows" ] || [ "$WSL" = true ]; then
  SKIP_ZSH_INSTALL=true
fi

# Only run installation if not already set up
if [ "$SKIP_INSTALL" = false ]; then
  install_packages
  if [ "$SKIP_ZSH_INSTALL" = false ]; then
    install_omz
    setup_zsh_default

    # Verify zsh is installed before handoff
    if ! command -v zsh >/dev/null 2>&1; then
      echo "${YELLOW}Warning: Zsh not found after attempted install. Proceeding to repo sync; zsh-dependent features will be skipped.${RESET}"
      # Avoid blocking execution: set skip flag so we don't rely on zsh later
      SKIP_ZSH_INSTALL=true
    fi
  else
    echo "${YELLOW}>> Skipping zsh/Oh-My-Zsh installation on Windows/WSL${RESET}"
  fi
else
  # In update mode
  if [ "$SKIP_ZSH_INSTALL" = false ]; then
    if ! command -v zsh >/dev/null 2>&1; then
      echo "${YELLOW}Warning: Zsh not found but .zshrc exists. Proceeding to repo sync (skipping zsh verification).${RESET}"
      # Avoid blocking update; skip zsh verification
      SKIP_ZSH_INSTALL=true
    fi
  else
    echo "${YELLOW}>> Running in Windows/WSL update mode: skipping zsh verification${RESET}"
  fi
  echo "${GREEN}>> Skipping to repository sync...${RESET}"
  sleep 1
fi

# =====================================================
# EXECUTION: PHASE 2 (INTERACTIVE REPO MANAGEMENT)
# =====================================================

clear
print_box "Phase 2" "Handoff & Repo Management"

echo ""
echo "${CYAN}_________________________________________${RESET}"
echo " STATIK_FINTECH // SYSTEM_HANDOFF"
echo "${CYAN}-----------------------------------------${RESET}"

# --- CHECK EXISTING GIT CONFIG ---
EXISTING_USER=$(git config --global user.name 2>/dev/null)
EXISTING_EMAIL=$(git config --global user.email 2>/dev/null)
HAS_CREDENTIALS=false
if [ -f "$HOME/.git-credentials" ]; then
  HAS_CREDENTIALS=true
fi

SKIP_GIT_CONFIG=false
if [ -n "$EXISTING_USER" ] && [ -n "$EXISTING_EMAIL" ] && [ "$HAS_CREDENTIALS" = true ]; then
  echo "${GREEN}>> EXISTING GIT CONFIGURATION DETECTED${RESET}"
  echo "   User:  $EXISTING_USER"
  echo "   Email: $EXISTING_EMAIL"
  echo "   Credentials: Stored"
  printf "${YELLOW}Use existing configuration? (y/n): ${RESET}"
  read -r USE_EXISTING < /dev/tty
  if printf '%s' "$USE_EXISTING" | grep -qi '^y' >/dev/null 2>&1; then
    GH_USER="$EXISTING_USER"
    GH_EMAIL="$EXISTING_EMAIL"
    SKIP_GIT_CONFIG=true
  else
    SKIP_GIT_CONFIG=false
  fi
else
  SKIP_GIT_CONFIG=false
fi

if [ "$SKIP_GIT_CONFIG" = false ]; then
  echo ""
  printf "${BOLD}GitHub Username:${RESET} "
  read -r GH_USER < /dev/tty
  if [ -z "$GH_USER" ]; then echo "${RED}Error: Username cannot be empty${RESET}"; exit 1; fi
  printf "${BOLD}GitHub Email:   ${RESET} "
  read -r GH_EMAIL < /dev/tty
  if [ -z "$GH_EMAIL" ]; then echo "${RED}Error: Email cannot be empty${RESET}"; exit 1; fi
  printf "${BOLD}GitHub Token:   ${RESET} "
  read -s GH_TOKEN < /dev/tty
  echo ""

  # --- APPLYING GIT CONFIG ---
  git config --global user.name "$GH_USER" || { echo "${RED}Error: Failed to set git username${RESET}"; exit 1; }
  git config --global user.email "$GH_EMAIL" || { echo "${RED}Error: Failed to set git email${RESET}"; exit 1; }
  git config --global credential.helper store

  if [ -n "$GH_USER" ] && [ -n "$GH_TOKEN" ]; then
    GH_USER_ENC=$(printf '%s' "$GH_USER" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    GH_TOKEN_ENC=$(printf '%s' "$GH_TOKEN" | sed 's/@/%40/g; s/:/%3A/g; s/ /%20/g; s/\//%2F/g; s/+/%2B/g; s/=/%3D/g')
    printf "https://%s:%s@github.com\n" "$GH_USER_ENC" "$GH_TOKEN_ENC" > "$HOME/.git-credentials"
    chmod 600 "$HOME/.git-credentials"
    printf "${GREEN}[ SUCCESS ] Credentials Encrypted & Stored.${RESET}\n"
  else
    printf "${YELLOW}[ WARNING ] Incomplete credentials. Skipping Auth write.${RESET}\n"
  fi
  sleep 1
fi

# Determine builds directory: prefer STATIK_BUILD_DIR, then PWD/builds, fallback to HOME/builds, else create PWD/builds
if [ -n "${STATIK_BUILD_DIR:-}" ]; then
  BUILD_DIR="$STATIK_BUILD_DIR"
  echo "${CYAN}>> Using build directory from STATIK_BUILD_DIR: ${BUILD_DIR}${RESET}"
else
  if [ -d "$PWD/builds" ]; then
    BUILD_DIR="$PWD/builds"
  elif [ -d "$HOME/builds" ]; then
    BUILD_DIR="$HOME/builds"
  else
    BUILD_DIR="$PWD/builds"
    mkdir -p "$BUILD_DIR" || { echo "${RED}Error: Cannot create builds directory ${BUILD_DIR}${RESET}"; exit 1; }
  fi
  echo "${CYAN}>> Using build directory: ${BUILD_DIR}${RESET}"
  # If interactive and BUILD_DIR is not inside current PWD, confirm with user
  if [ -t 1 ]; then
    case "$BUILD_DIR/" in
      "$PWD/")
        ;; # same tree, continue
      "$PWD/"*)
        ;; # same tree, continue
      *)
        printf '%b' "${YELLOW}>> Selected build directory %s is not under current directory %s. Continue? (y/n): ${RESET}" "$BUILD_DIR" "$PWD"
        read -r CONF_BD < /dev/tty
        if ! printf '%s' "$CONF_BD" | grep -qi '^y' >/dev/null 2>&1; then
          echo "${YELLOW}Aborting; set STATIK_BUILD_DIR to the desired builds directory and rerun.${RESET}"
          exit 1
        fi
        ;;
    esac
  fi
fi

cd "$BUILD_DIR" || { echo "${RED}Error: Cannot access builds directory ${BUILD_DIR}${RESET}"; exit 1; }

# Diagnostic: list build directory entries and show git origins (helps detect false positives)
echo "${CYAN}>> Build dir contents:${RESET}"
for d in "$BUILD_DIR"/*; do
  [ -e "$d" ] || continue
  name=$(basename "$d")
  if [ -d "$d/.git" ]; then
    origin=$(cd "$d" && git config --get remote.origin.url 2>/dev/null || echo "no-origin")
    echo " - ${name}: git repo (origin: ${origin})"
  else
    echo " - ${name}: not a git repo"
  fi
done

# Extract token from credentials if not provided
if [ -z "$GH_TOKEN" ] && [ -f "$HOME/.git-credentials" ]; then
  GH_TOKEN=$(sed -n 's|.*https://[^:]*:\([^@]*\)@github.com.*|\1|p' "$HOME/.git-credentials" | head -n1 2>/dev/null || true)
fi

if [ -n "$GH_TOKEN" ]; then
  AUTH_HEADER="Authorization: token $GH_TOKEN"
else
  AUTH_HEADER="User-Agent: statik-bot"
fi

API_USER="${GH_USER:-$EXISTING_USER}"
if [ -z "$API_USER" ]; then echo "${RED}Error: No GitHub username available${RESET}"; exit 1; fi

JSON_DATA=$(curl -s -H "$AUTH_HEADER" "https://api.github.com/users/$API_USER/repos?per_page=200")

# Ensure jq is available or prompt to install; otherwise fall back to simple parsing
USE_JQ=true
if ! command -v jq >/dev/null 2>&1; then
  printf "${YELLOW}Note: 'jq' is required to parse GitHub JSON efficiently and was not found. Install now? (y/n): ${RESET}"
  read -r INSTALL_JQ < /dev/tty
  if printf '%s' "$INSTALL_JQ" | grep -qi '^y' >/dev/null 2>&1; then
    case $OS in
      alpine)
        apk update >/dev/null 2>&1 || true
        if ! apk add --no-cache jq >/dev/null 2>&1; then
          echo "${RED}Failed to install jq${RESET}"
          USE_JQ=false
        fi
        ;;
      ubuntu|debian)
        if command -v sudo >/dev/null 2>&1; then
          sudo apt-get update -qq >/dev/null 2>&1 || true
          sudo apt-get install -qq -y jq >/dev/null 2>&1 || { echo "${RED}Failed to install jq${RESET}"; USE_JQ=false; }
        else
          echo "${RED}Cannot install jq without sudo. Please install jq and rerun.${RESET}"
          USE_JQ=false
        fi
        ;;
      macos)
        if command -v brew >/dev/null 2>&1; then
          brew install jq >/dev/null 2>&1 || { echo "${RED}Failed to install jq${RESET}"; USE_JQ=false; }
        else
          echo "${RED}Homebrew not found. Cannot install jq automatically.${RESET}"
          USE_JQ=false
        fi
        ;;
      *)
        echo "${YELLOW}Automatic jq installation is not supported on this OS.${RESET}"
        USE_JQ=false
        ;;
    esac
  else
    echo "${YELLOW}Proceeding without jq; will attempt fallback parsing.${RESET}"
    USE_JQ=false
  fi
fi

if [ "$USE_JQ" = true ]; then
  IS_VALID=$(echo "$JSON_DATA" | jq -r 'if type=="array" then "yes" else "no" end' 2>/dev/null)
  if [ "$IS_VALID" != "yes" ]; then
    echo "${RED}[ ERROR ] Unable to fetch repos. Check Token or API Status.${RESET}"
    ERROR_MSG=$(echo "$JSON_DATA" | jq -r '.message // "Unknown error"' 2>/dev/null)
    echo "API Response: $ERROR_MSG"
    exit 1
  fi
  echo "$JSON_DATA" | jq -r '.[] | "\(.name)|\(.clone_url)"' > /tmp/statik_repos.txt
  TOTAL_REPOS=$(wc -l < /tmp/statik_repos.txt | tr -d ' ')
  if [ "${TOTAL_REPOS:-0}" -eq 0 ]; then echo "${YELLOW}>> NO REPOSITORIES FOUND${RESET}"; exit 0; fi
  printf "\r${YELLOW}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n"
else
  # Fallback parsing without jq (best-effort)
  rm -f /tmp/statik_repos.txt
  name=""
  url=""
  echo "$JSON_DATA" | tr ',' '\n' | while IFS= read -r line; do
    if printf "%s" "$line" | grep -q '"name"'; then
      name=$(printf "%s" "$line" | sed -n 's/.*"name":[[:space:]]*"\([^"]*\)".*/\1/p')
    fi
    if printf "%s" "$line" | grep -q '"clone_url"'; then
      url=$(printf "%s" "$line" | sed -n 's/.*"clone_url":[[:space:]]*"\([^"]*\)".*/\1/p')
    fi
    if [ -n "$name" ] && [ -n "$url" ]; then
      printf "%s|%s\n" "$name" "$url" >> /tmp/statik_repos.txt
      name=""
      url=""
    fi
  done
  TOTAL_REPOS=$(wc -l < /tmp/statik_repos.txt | tr -d ' ')
  if [ "${TOTAL_REPOS:-0}" -eq 0 ]; then echo "${YELLOW}>> NO REPOSITORIES FOUND (fallback parsing)${RESET}"; exit 0; fi
  printf "\r${YELLOW}>> TARGETS ACQUIRED: ${TOTAL_REPOS}      ${RESET}\n\n"
fi

get_repo_line() { sed -n "${1}p" /tmp/statik_repos.txt; }

do_clone() {
  name="$1"; url="$2"
  target="$BUILD_DIR/$name"

  # If target exists and contains a git repo, verify remote origin before skipping
  if [ -d "$target/.git" ]; then
    if (cd "$target" && git rev-parse --is-inside-work-tree >/dev/null 2>&1); then
      existing_origin=$(cd "$target" && git config --get remote.origin.url 2>/dev/null || true)
      # Normalize URLs for comparison: strip .git and convert git@host:path to https://host/path
      norm_existing=$(printf '%s' "$existing_origin" | sed -e 's/\.git$//' -e 's/^git@/https:\/\//' -e 's/:/\//')
      norm_expected=$(printf '%s' "$url" | sed -e 's/\.git$//' -e 's/^git@/https:\/\//' -e 's/:/\//')
      if [ -n "$existing_origin" ] && [ "$norm_existing" = "$norm_expected" ]; then
        echo "${YELLOW}>> ${name} already exists at ${target} (origin matches ${existing_origin}). Skipping clone.${RESET}"
        return 0
      fi
      echo "${YELLOW}>> ${name} already exists at ${target} with origin: ${existing_origin:-unknown} (expected: ${url}).${RESET}"
      printf '%b' "${YELLOW}Remove ${target} and attempt fresh clone? (y/n): ${RESET}"
      read -r RECLONE < /dev/tty
      if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
        rm -rf "$target" && echo "${GREEN}Removed local copy of ${name}${RESET}"
      else
        echo "${YELLOW}Skipping clone for ${name}.${RESET}"
        return 1
      fi
    fi
  elif [ -d "$target" ]; then
    echo "${YELLOW}>> ${target} exists but is not a git repository.${RESET}"
    printf '%b' "${YELLOW}Remove ${target} and attempt clone? (y/n): ${RESET}"
    read -r RECLONE < /dev/tty
    if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
      rm -rf "$target" && echo "${GREEN}Removed local copy of ${name}${RESET}"
    else
      echo "${YELLOW}Skipping clone for ${name}.${RESET}"
      return 1
    fi
  fi

  echo "${CYAN}Cloning $name into ${target}...${RESET}"

  # Helper to log git failures
  log_file="/tmp/git_clone_${name}.log"
  rm -f "$log_file"

  # If running in iSH (Alpine and not WSL), prefer shallow clone to reduce memory
  if [ "${OS}" = "alpine" ] && [ "${WSL}" != true ]; then
    if git clone --depth=1 "$url" "$target" >"$log_file" 2>&1; then
      echo "${GREEN}Shallow cloned $name${RESET}"
      return 0
    else
      echo "${YELLOW}Shallow clone failed; attempting full clone (may fail on iSH). See $log_file for details.${RESET}"
      git --version >>"$log_file" 2>&1 || true
      if git clone "$url" "$target" >"$log_file" 2>&1; then
        echo "${GREEN}Cloned $name (full clone success)${RESET}"
        return 0
      else
        echo "${RED}Failed to clone $name. See $log_file for details.${RESET}"
        return 1
      fi
    fi
  else
    # Normal systems: full clone
    if git clone "$url" "$target" >"$log_file" 2>&1; then
      echo "${GREEN}Cloned $name${RESET}"
      return 0
    else
      echo "${RED}Failed to clone $name. See $log_file for details.${RESET}"
      return 1
    fi
  fi
} 

do_update() {
  name="$1"
  target="$BUILD_DIR/$name"
  log_file="/tmp/git_update_${name}.log"
  rm -f "$log_file"

  if [ ! -d "$target/.git" ]; then echo "${YELLOW}>> $name is not present. Use install first.${RESET}"; return 1; fi

  echo "${CYAN}Updating $name...${RESET}"
  # Capture git version and environment for debugging
  git --version >"$log_file" 2>&1 || true
  echo "--- fetch output ---" >>"$log_file"

  # If on iSH, prefer shallow fetch then hard reset to origin/branch to reduce memory
  if [ "${OS}" = "alpine" ] && [ "${WSL}" != true ]; then
    branch=$(cd "$target" && git rev-parse --abbrev-ref HEAD 2>/dev/null || echo master)
    if (cd "$target" && git fetch --depth=1 origin >"$log_file" 2>&1); then
      if (cd "$target" && git reset --hard origin/"$branch" >"$log_file" 2>&1); then
        echo "${GREEN}Updated $name (shallow)${RESET}"
        return 0
      else
        echo "${YELLOW}Fetch succeeded but reset failed for $name; see $log_file${RESET}"
      fi
    else
      echo "${RED}Shallow fetch failed for $name; see $log_file${RESET}"
    fi

    # Offer to re-clone shallow if fetch/reset failed
    printf '%b' "${YELLOW}Update failed for $name. Attempt fresh shallow clone (this will remove local copy)? (y/n): ${RESET}"
    read -r RECLONE < /dev/tty
    if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
      rm -rf "$target" && echo "Removed local copy of $name"
      do_clone "$name" "$2"
      return $?
    else
      echo "${YELLOW}Skipping re-clone for $name.${RESET}"
      return 1
    fi
  else
    # Non-iSH / normal systems: attempt fast pull
    if (cd "$target" && git pull --ff-only >"$log_file" 2>&1); then
      echo "${GREEN}Updated $name${RESET}"
      return 0
    else
      echo "${RED}Update failed for $name. See $log_file for details.${RESET}"
      printf '%b' "${YELLOW}Attempt fresh clone to recover? (y/n): ${RESET}"
      read -r RECLONE < /dev/tty
      if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
        rm -rf "$target" && echo "Removed local copy of $name"
        do_clone "$name" "$2"
        return $?
      else
        echo "${YELLOW}Skipping re-clone for $name.${RESET}"
        return 1
      fi
    fi
  fi
} 

do_status() {
  name="$1"
  target="$BUILD_DIR/$name"
  if [ ! -d "$target/.git" ]; then echo "${YELLOW}>> $name is not present.${RESET}"; return; fi
  echo "${CYAN}Status for $name:${RESET}"
  if ! (cd "$target" && git status --short); then
    echo "${RED}Failed to show status for $name (see /tmp/git_status_${name}.log)${RESET}"
    (cd "$target" && git --version) >"/tmp/git_status_${name}.log" 2>&1 || true
  fi
}

do_commit() {
  name="$1"
  target="$BUILD_DIR/$name"
  if [ ! -d "$target/.git" ]; then echo "${YELLOW}>> $name is not present.${RESET}"; return; fi
  echo "${CYAN}Enter commit message for $name:${RESET}"
  read -r CM < /dev/tty
  if [ -z "$CM" ]; then echo "${YELLOW}No message provided. Skipping commit.${RESET}"; return; fi
  (cd "$target" && git add -A && git commit -m "$CM" >/dev/null 2>&1 && git push) && echo "${GREEN}Committed & pushed in $name${RESET}" || echo "${YELLOW}Nothing to commit or push failed in $name${RESET}"
} 

do_delete() {
  name="$1"
  target="$BUILD_DIR/$name"
  echo "${RED}Confirm delete of ${name}? Type 'yes' to confirm:${RESET}"
  read -r CONF < /dev/tty
  if [ "$CONF" = "yes" ]; then rm -rf "$target" && echo "${GREEN}Deleted $name${RESET}" || echo "${RED}Failed to delete $name${RESET}"; else echo "${YELLOW}Aborted delete of $name${RESET}"; fi
}

# Hand off to zsh if available, otherwise keep sh selection/execution (TTY-safe)
if command -v zsh >/dev/null 2>&1; then
  end_blackout
  export BUILD_DIR GH_USER
  cat << 'ZSHPHASE' > /tmp/statik_phase2.zsh
#!/usr/bin/env zsh
# Phase 2 (zsh): red/gold theme + selection-first then execution
RED="$(printf '\033[38;5;124m')"
GOLD="$(printf '\033[38;5;220m')"
RESET="$(printf '\033[0m')"
clear
printf '%b\n' "${RED}"
cat << 'HEADER'
 _________________________________________
|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|1|0|
 STATIK_FINTECH // SYSTEM_HANDOFF
|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|_|
HEADER
printf '%b\n' "${RESET}"
ACTIONS_FILE=/tmp/statik_actions.txt
rm -f "${ACTIONS_FILE}"
i=0
TOTAL_REPOS=$(wc -l < /tmp/statik_repos.txt || echo 0)
while IFS='|' read -r name url; do
  i=$((i+1))
  printf '%b\n' "${GOLD}Target ${i}/${TOTAL_REPOS}: ${name}${RESET}"
  while true; do
    printf '%b' "${RED}Action for ${name} [i=install u=update s=status c=commit d=delete p=pass q=quit]: ${RESET}"
    read -r action < /dev/tty
    case "${action}" in
      i|u|c|d|p)
        printf '%s|%s|%s\n' "${name}" "${url}" "${action}" >> "${ACTIONS_FILE}"
        break
        ;;
      s)
        if [ -d "${BUILD_DIR}/${name}" ]; then
          (cd "${BUILD_DIR}/${name}" && git status --short) || echo "Failed to show status for ${name}"
        else
          echo "Repo not present"
        fi
        ;;
      q)
        echo "User aborted"
        exit 0
        ;;
      *)
        echo "Unknown action: ${action}"
        ;;
    esac
  done
done < /tmp/statik_repos.txt

if [ -f "${ACTIONS_FILE}" ]; then
  echo "Executing actions..."
  while IFS='|' read -r pname purl paction; do
    case "${paction}" in
      i)
        if [ -d "${BUILD_DIR}/${pname}/.git" ]; then
          if (cd "${BUILD_DIR}/${pname}" && git rev-parse --is-inside-work-tree >/dev/null 2>&1); then
            existing_origin=$(cd "${BUILD_DIR}/${pname}" && git config --get remote.origin.url 2>/dev/null || true)
            norm_existing=$(printf '%s' "$existing_origin" | sed -e 's/\.git$//' -e 's/^git@/https:\/\//' -e 's/:/\//')
            norm_expected=$(printf '%s' "${purl}" | sed -e 's/\.git$//' -e 's/^git@/https:\/\//' -e 's/:/\//')
            if [ -n "$existing_origin" ] && [ "$norm_existing" = "$norm_expected" ]; then
              echo "${pname} already present at ${BUILD_DIR}/${pname} (origin matches). Skipping clone"
            else
              printf '%b' "${GOLD}${pname} has a .git but origin mismatch (found: ${existing_origin:-unknown}). Remove and re-clone? (y/n): ${RESET}"
              read -r RECLONE < /dev/tty
              if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
                rm -rf "${BUILD_DIR}/${pname}"
                git clone "${purl}" "${BUILD_DIR}/${pname}" && echo "Cloned ${pname}" || echo "Failed to clone ${pname}"
              else
                echo "Skipping ${pname}"
              fi
            fi
          else
            printf '%b' "${GOLD}${pname} exists but is not a git repo. Remove and clone? (y/n): ${RESET}"
            read -r RECLONE < /dev/tty
            if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
              rm -rf "${BUILD_DIR}/${pname}"
              git clone "${purl}" "${BUILD_DIR}/${pname}" && echo "Cloned ${pname}" || echo "Failed to clone ${pname}"
            else
              echo "Skipping ${pname}"
            fi
          fi
        elif [ -d "${BUILD_DIR}/${pname}" ]; then
          printf '%b' "${GOLD}${pname} exists but is not a git repo. Remove and clone? (y/n): ${RESET}"
          read -r RECLONE < /dev/tty
          if printf '%s' "$RECLONE" | grep -qi '^y' >/dev/null 2>&1; then
            rm -rf "${BUILD_DIR}/${pname}"
            git clone "${purl}" "${BUILD_DIR}/${pname}" && echo "Cloned ${pname}" || echo "Failed to clone ${pname}"
          else
            echo "Skipping ${pname}"
          fi
        else
          git clone "${purl}" "${BUILD_DIR}/${pname}" && echo "Cloned ${pname}" || echo "Failed to clone ${pname}"
        fi
        ;;
      u)
        if [ -d "${BUILD_DIR}/${pname}/.git" ]; then
          (cd "${BUILD_DIR}/${pname}" && git pull --ff-only) && echo "Updated ${pname}" || echo "Update failed for ${pname}"
        else
          echo "${pname} not present to update"
        fi
        ;;
      c)
        if [ -d "${BUILD_DIR}/${pname}/.git" ]; then
          printf '%b' "${GOLD}Enter commit message for ${pname}:${RESET}"
          read -r CM < /dev/tty
          (cd "${BUILD_DIR}/${pname}" && git add -A && git commit -m "${CM}" >/dev/null 2>&1 && git push) && echo "Committed & pushed ${pname}" || echo "Nothing to commit or push failed for ${pname}"
        else
          echo "${pname} not present"
        fi
        ;;
      d)
        printf '%b' "${RED}Confirm delete of ${pname}? Type 'yes' to confirm:${RESET}"
        read -r CONF < /dev/tty
        if [ "${CONF}" = "yes" ]; then rm -rf "${BUILD_DIR}/${pname}" && echo "Deleted ${pname}" || echo "Failed to delete ${pname}"; fi
        ;;
      p)
        echo "Skipped ${pname}"
        ;;
    esac
  done < "${ACTIONS_FILE}"
  rm -f "${ACTIONS_FILE}"
fi

echo "${GOLD}All tasks complete. Repositories located at: ${BUILD_DIR}${RESET}"
ZSHPHASE
  chmod +x /tmp/statik_phase2.zsh
  exec zsh /tmp/statik_phase2.zsh
else
  # Fallback: keep sh-based selection/execution (TTY-safe)
  end_blackout
  ACTIONS_FILE="/tmp/statik_actions.txt"
  rm -f "$ACTIONS_FILE"
  count=0
  echo "${CYAN}Phase: Selection (choose action for each target). Choices will be executed after selection completes.${RESET}"
  while IFS='|' read -r rname rurl; do
    count=$((count + 1))
    printf '%b\n' "${CYAN}-----------------------------------------${RESET}"
    printf '%b' "${BOLD}Target ${count}/${TOTAL_REPOS}:${RESET} "
    printf '%b\n' "${rname}"
    while true; do
      printf '%b' "${YELLOW}Select action for ${rname} [i=install u=update s=status c=commit d=delete p=pass q=quit]: ${RESET}"
      read -r REPLY_ACTION < /dev/tty
      case "$REPLY_ACTION" in
        i|u|c|d|p)
          printf '%s|%s|%s\n' "$rname" "$rurl" "$REPLY_ACTION" >> "$ACTIONS_FILE"
          break
          ;;
        s)
          do_status "$rname"
          ;;
        q)
          echo "Selection aborted by user."
          exit 0
          ;;
        *)
          echo "Unknown action: $REPLY_ACTION"
          ;;
      esac
    done
  done < /tmp/statik_repos.txt

  echo "${CYAN}Phase: Execution — running selected actions...${RESET}"
  PROC_COUNT=0
  while IFS='|' read -r pname purl paction; do
    PROC_COUNT=$((PROC_COUNT + 1))
    printf '%b\n' "${CYAN}-----------------------------------------${RESET}"
    printf '%b\n' "${BOLD}Processing ${PROC_COUNT}/${TOTAL_REPOS}: ${pname}${RESET}"
    case "$paction" in
      i) do_clone "$pname" "$purl" ;;
      u) do_update "$pname" "$purl" ;;
      s) do_status "$pname" ;;
      c) do_commit "$pname" ;;
      d) do_delete "$pname" ;;
      p) printf '%b\n' "${CYAN}Skipped ${pname}${RESET}" ;;
      *) printf '%b\n' "${YELLOW}Unknown preset action: ${paction} for ${pname}${RESET}" ;;
    esac
  done < "$ACTIONS_FILE"
  rm -f "$ACTIONS_FILE"
  echo "${GREEN}All tasks complete. Repositories located at: ${BUILD_DIR}${RESET}"
fi

